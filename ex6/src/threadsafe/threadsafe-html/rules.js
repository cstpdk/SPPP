var rules = {"CCE_FF_VOLATILE":{"name":"Volatile field only written during initialization","category":"Immutability","description":"<p>The reported field is volatile, but all writes to the field\n      occur during initialization. If the field references an array or\n      collection object, this may indicate a misunderstanding about\n      the semantics of volatile fields in Java.<\/p>\n\n      <h2>Details<\/h2>\n\n      <p>This rule checks that there are no fields that are declared\n      as volatile, but are only written to during object or class\n      initialization.<\/p>\n\n      <p>The following code snippet demonstrates two cases where\n      ThreadSafe will report a warning that a volatile field is only\n      written to during initialization.<\/p>\n\n      <pre><code>\n      public class LoggedIncrementingList {\n\n          private volatile int[] items;\n\n          private volatile List&lt;String&gt; log;\n\n          public LoggedIncrementingList() {\n              items = new int[1024];\n              initalizeLog();\n          }\n\n          private void initialiseLog() {\n              log = new LinkedList&lt;String&gt;();\n          }\n\n          public void increment(int i) {\n              log.add(\"Request \" + i);\n              items[i]++;\n          }\n\n      }\n      <\/code><\/pre>\n\n      <p>The fields <code>items<\/code> and <code>log<\/code> are both\n      declared as <code>volatile<\/code>, but both fields are only\n      written to during object initialization. The field\n      <code>items<\/code> is only written to in the constructor, while\n      the field <code>log<\/code> is written to in a private method\n      that is only called from the constructor.<\/p>\n\n      <p>Note that, for both fields, the <em>collection<\/em> stored in\n      each field is written to in the public method\n      <code>increment<\/code>, but the field itself is never\n      changed.<\/p>\n\n      <h2>Risks and Remediation<\/h2>\n\n      <p>It is sometimes assumed that declaring a field as volatile\n      will provide volatile semantics for the object or array\n      referenced by the field. However, volatile semantics are only\n      guaranteed for the field itself, and not the object or array\n      that the field references. Expecting volatile semantics for\n      array or collection elements will result in undefined behaviour\n      when accessing them from multiple threads, leading to data\n      corruption and unpredictable results.<\/p>\n\n      <h3>Arrays<\/h3>\n\n      <p>A field of array type that is declared as volatile only has\n      volatile semantics for the array reference. The array elements\n      themselves do not have volatile semantics.  If volatile\n      semantics are required for an array, consider using one of the\n      atomic array classes from the <code>java.util.concurrent<\/code>\n      package:\n      <ul>\n      <li><code>AtomicIntegerArray<\/code>;<\/li>\n      <li><code>AtomicLongArray<\/code>; or<\/li>\n      <li><code>AtomicReferenceArray<\/code>.<\/li>\n      <\/ul>\n      If the size of the array never needs to change, then the field\n      can be declared final. For more information, consult <em>Java\n      Concurrency in Practice<\/em>, Section&nbsp;15.3: Atomic variable\n      classes.<\/p>\n\n      <h3>Collections, and other kinds of Object<\/h3>\n\n      <p>A field of object type that is declared as volatile only has\n      volatile semantics for the object reference. The fields of that\n      object will not have volatile semantics unless they are declared\n      so.<\/p>\n\n      <h3>Fields that could be made final<\/h3>\n\n      <p>It is good practice to declare fields as final if they are\n      not modified after the object is constructed, where possible.\n      It is simpler to reason about the behaviour of a class in a\n      multi-threaded environment if most of the fields are final than\n      a similar class where most of the fields are not declared\n      final.<\/p>\n\n      <p>For more information about how to effectively use final and\n      volatile fields in a multi-threaded program, please consult\n      <em>Java Concurrency in Practice<\/em>,\n      Sections&nbsp;3.14&nbsp;and&nbsp;3.4.1.<\/p>"}
,"CCE_SL_INCONSISTENT":{"name":"Inconsistent synchronization of accesses to a field","category":"Locking","description":"<p>The field is usually, but not always, accessed while holding a\n    lock. The programmer may have intended that all accesses were to\n    be protected by a single lock, but has missed some.<\/p>\n\n    <p>If concurrent reads and writes to a field are not synchronized,\n    the program will be prone to data races, and data corruption and\n    unpredictable behaviour will result.<\/p>\n\n    <p>When viewing a finding of this type in Eclipse, it is possible\n    to discover which locks are involved with accesses to this field\n    by using the <strong>Accesses view<\/strong>. The Accesses view can\n    be opened by following the 'Accesses and Locks' link in the detail\n    pane to the right of the ThreadSafe view.<\/p>\n\n    <h2>Details<\/h2>\n\n    <p>This rule looks for fields that are usually accessed with\n    synchronization by some lock, but in some places are accessed\n    without synchronization by a lock.<\/p>\n\n    <p>The following code snippet demonstrates an example of a class\n    declaration for which ThreadSafe will warn that the field\n    <code>x<\/code> has been inconsistently synchronized.<\/p>\n\n    <pre><code>\n      public class Counter {\n\n          private int x;\n\n          public synchronized void incrementX() {\n              x++;\n          }\n\n          public synchronized void decrementX() {\n              x--;\n          }\n\n          public int getX() {\n              return x;\n          }\n\n      }\n    <\/code><\/pre>\n\n    <p>The methods <code>incrementX()<\/code> and\n    <code>decrementX()<\/code> synchronize their accesses to the field\n    <code>x<\/code> using the intrinsic lock associated with the object\n    instance. However, the method <code>getX()<\/code> does not\n    participate in the synchronization, and so there is a risk of a\n    data race occuring between the writes in the first two methods and\n    the read in <code>getX()<\/code>. Concretely, this may result in\n    <code>getX()<\/code> returning values that are grossly outdated, or\n    even just always returning <code>0<\/code> (the default value for\n    fields of type <code>int<\/code>), depending on the underlying\n    machine architecture.<\/p>\n\n    <p>ThreadSafe examines all accesses to every field, whether they\n    occur within the same class that the field is declared, a subclass\n    of that class, inner or outer classes, or any other class within\n    the set of classes being analyzed. Accesses to fields that are\n    only reachable from instance or class initializers are discounted\n    as they are unlikely to be executed concurrently with other method\n    invocations on the same object.<\/p>\n\n    <p>An access is regarded as synchronized if it occurs either while\n    an intrinsic lock is held (via use of the\n    <code>synchronized<\/code> keyword), or if a first-class\n    <code>java.util.concurrent.locks.Lock<\/code> has been acquired and\n    is yet to be released.<\/p>\n\n    <h2>Risks and Remediation<\/h2>\n\n    <p>For the avoidance of data races, it is important that fields\n    that are accessed concurrently are consistently guarded by a\n    common lock. Reads, as well as writes, such as those that occur in\n    getter methods, need to be synchronized. Failure to correctly\n    synchronize concurrent reads and writes can lead to corrupted data\n    and unpredictable behavior.<\/p>\n\n    <p>Inconsistent synchronization warnings can be fixed by ensuring\n    that all accesses to the named field are guarded by the same\n    lock.<\/p>\n\n    <h2>Parameters<\/h2>\n    <dl>\n    <dt>threshold<\/dt>\n    <dd>\n    This sets the threshold ratio of unsynchronized to synchronized\n    accesses that are required before a field is reported as\n    inconsistently synchronized. The lower this is set, the more\n    sensitive the analysis is, but the more likely it is to report\n    false positives. The default value is 70. Field writes are\n    weighted more heavily than reads.\n    <\/dd>\n    <\/dl>"}
,"CCE_SL_MIXED":{"name":"Mixed synchronization of accesses to a field","category":"Locking","description":"<p>The field is always accessed with a lock held, but there is no\n    single lock that is common to all accesses. The programmer may\n    have intended that all accesses were to be protected by a single\n    lock, but has mistakenly used two or more different locks.<\/p>\n\n    <p>If concurrent reads and writes to the field are not\n    synchronized with a common lock, then the program will be prone to\n    data races, and hence data corruption and unpredictable\n    behaviour.<\/p>\n\n    <p>When viewing a finding of this type in Eclipse, it is possible\n    to discover which locks are involved with accesses to this field\n    by using the <strong>Accesses view<\/strong>. The Accesses view can\n    be opened by following the 'Accesses and Locks' link in the detail\n    pane to the right of the ThreadSafe view.<\/p>\n\n    <h2>Details<\/h2>\n\n    <p>This rule looks for fields that are always accessed with locks\n    held, but there is no one lock that is common to all accesses.<\/p>\n\n    <p>The following code snippet demonstrates an example of a class\n    declaration for which ThreadSafe will warn that the field\n    <code>x<\/code> has been accessed with mixed synchronization.<\/p>\n\n    <pre><code>\n      public class IncrementorDecrementor {\n\n          private int x;\n\n          private final Object lock = new Object();\n\n          public synchronized void incrementX() {\n              x++;\n          }\n\n          public synchronized void decrementX() {\n              x--;\n          }\n\n          public void getX() {\n              synchronized (lock) {\n                  return x;\n              }\n          }\n\n      }\n    <\/code><\/pre>\n\n    <p>The methods <code>incrementX()<\/code> and\n    <code>decrementX()<\/code> synchronize their accesses to the field\n    <code>x<\/code> using the intrinsic lock associated with the object\n    instance. However, the method <code>getX()<\/code> synchronizes on\n    the intrinsic lock associated with the object in the field\n    <code>lock<\/code>, so there is a risk of a data race occuring\n    between the writes in the first two methods and the read in\n    <code>getX()<\/code>. Concretely, this may result in\n    <code>getX()<\/code> returning values that are grossly outdated, or\n    even just always returning <code>0<\/code> (the default value for\n    fields of type <code>int<\/code>), depending on the underlying\n    machine architecture.<\/p>\n\n    <p>ThreadSafe examines all accesses to every field, whether they\n    occur within the same class that the field is declared, a subclass\n    of that class, inner or outer classes, or any other class within\n    the set of classes being analyzed. Accesses to fields that are\n    only reachable from instance or class initializers are discounted\n    as they are unlikely to be executed concurrently with other method\n    invocations on the same object.<\/p>\n\n    <p>An access is regarded as synchronized if it occurs either while\n    an intrinsic lock is held (via use of the\n    <code>synchronized<\/code> keyword), or if a first-class\n    <code>java.util.concurrent.locks.Lock<\/code> has been acquired and\n    is yet to be released.<\/p>\n\n    <h2>Risks and Remediation<\/h2>\n\n    <p>For the avoidance of dataraces, it is important that fields\n    that are accessed concurrently are consistently guarded by a\n    common lock. Reads, as well as writes, such as those that occur in\n    getter methods, all need to be synchronized with the same\n    lock. Failure to correctly synchronize concurrent reads and writes\n    can lead to corrupted data and unpredictable behavior.<\/p>\n\n    <p>Mixed synchronization warnings can be fixed by ensuring that\n    all accesses to the named field are guarded by the same\n    lock.<\/p>"}
,"CCE_SL_MIXED_COL":{"name":"Mixed synchronization of accesses to a collection stored in a field","category":"Locking","description":"<p>The field contains an array or collection not designed for\n    concurrent access and is always accessed with a lock held, but\n    there is no single lock that is common to all accesses. The\n    programmer may have intended that all accesses were to be\n    protected by a single lock, but has mistakenly used two or more\n    different locks.<\/p>\n\n    <p>If concurrent reads and writes to the referenced object are not\n    synchronized with a common lock, then the program will be prone to\n    data races, data corruption and unpredictable behaviour. <\/p>\n\n    <p>When viewing a finding of this type in Eclipse, it is possible\n    to discover which locks are involved with accesses to this field\n    by using the <strong>Accesses view<\/strong>. The Accesses view can\n    be opened by following the 'Accesses and Locks' link in the detail\n    pane to the right of the ThreadSafe view.<\/p>\n\n    <h2>Details<\/h2>\n\n    <p>This rule looks for non threadsafe collections that are stored\n    in a field, where the field is always accessed with locks held,\n    but there is no one lock that is common to all accesses.<\/p>\n\n    <p>The following code snippet demonstrates an example of a class\n    declaration for which ThreadSafe will warn that the collection\n    stored in the field <code>list<\/code> has been accessed with mixed\n    synchronization.<\/p>\n\n    <pre><code>\n      public class Stack {\n\n          private final List&lt;Integer&gt; list = new LinkedList&lt;Integer&gt;();\n\n          private final Object lock = new Object();\n\n          public synchronized void push(int value) {\n              list.add(0, value);\n          }\n\n          public synchronized void pop() {\n              list.remove(0);\n          }\n\n          public void peek() {\n              synchronized (lock) {\n                  return list.get(0);\n              }\n          }\n\n      }\n    <\/code><\/pre>\n\n    <p>The methods <code>push(int value)<\/code> and <code>pop()<\/code>\n    synchronize their accesses to the <code>LinkedList<\/code> in the\n    field <code>list<\/code> by using the intrinsic lock associated\n    with the object instance. However, the method\n    <code>peek()<\/code> synchronizes on the intrinsic lock\n    associated with the object in the field <code>lock<\/code>. Since\n    these are two different locks, there is a risk of a data race\n    occuring between the writes to the collection in the first two\n    methods and the read in <code>peek()<\/code>. Concretely, this\n    may result in the internal structure of the linked list becoming\n    corrupted, or <code>peek()<\/code> returning values that are\n    grossly outdated, depending on the exact implementation of the\n    <code>LinkedList<\/code> class and the underlying machine\n    architecture.<\/p>\n\n    <p>ThreadSafe examines all accesses to collections stored in\n    fields, whether they occur within the same class that the field is\n    declared, a subclass of that class, inner or outer classes, or any\n    other class within the set of classes being analyzed. Accesses to\n    collections stored in fields that are only reachable from instance\n    or class initializers are discounted as they are unlikely to be\n    executed concurrently with other method invocations on the same\n    object.<\/p>\n\n    <p>An access is regarded as synchronized if it occurs either while\n    an intrinsic lock is held (via use of the\n    <code>synchronized<\/code> keyword), or if a first-class\n    <code>java.util.concurrent.locks.Lock<\/code> has been acquired and\n    not yet released.<\/p>\n\n    <p>To determine whether or not a field may contain a non\n    threadsafe collection, ThreadSafe looks at the classes of object\n    that may be stored in the field, as well as the declared type of\n    the field. In the example above, the field <code>list<\/code> is\n    declared as type <code>List&lt;Integer&gt;<\/code>, which could\n    potentially be a threadsafe collection, such as\n    <code>CopyOnWriteArrayList<\/code>. However, ThreadSafe also sees\n    that the field has been assigned a <code>LinkedList<\/code>\n    instance. Since the class <code>LinkedList<\/code> is not designed\n    to be threadsafe, a mixed collection synchronization warning is\n    generated.<\/p>\n\n    <p>This rule applies to many of the collections in the java.util\n    package. The following is an excerpt from the Java API\n    documentation for <a\n    href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/util\/LinkedList.html\"\n    >LinkedList<\/a>:<\/p>\n\n    <blockquote style=\"background-color: #ddd;\">\n\n      <p><strong>Note that this implementation is not\n      synchronized.<\/strong> If multiple threads access a linked list\n      concurrently, and at least one of the threads modifies the list\n      structurally, it <i>must<\/i> be synchronized externally.  (A\n      structural modification is any operation that adds or deletes\n      one or more elements; merely setting the value of an element is\n      not a structural modification.)  This is typically accomplished\n      by synchronizing on some object that naturally encapsulates the\n      list.\n\n      If no such object exists, the list should be \"wrapped\" using the\n      <a\n      href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/util\/Collections.html#synchronizedList(java.util.List)\"\n      ><code>Collections.synchronizedList<\/code><\/a> method.  This is\n      best done at creation time, to prevent accidental unsynchronized\n      access to the list:<pre> List list =\n      Collections.synchronizedList(new LinkedList(...));<\/pre>\n    <\/blockquote>\n\n    <p>Similar constraints are documented for the following classes:<\/p>\n    <ul style=\"list-style-type: none;\">\n    <li><a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/util\/ArrayList.html\">ArrayList<\/a>\n    <li><a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/util\/LinkedList.html\">LinkedList<\/a>\n    <li><a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/util\/HashSet.html\">HashSet<\/a>\n    <li><a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/util\/TreeSet.html\">TreeSet<\/a>\n    <li><a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/util\/EnumMap.html\">EnumMap<\/a>\n    <li><a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/util\/HashMap.html\">HashMap<\/a>\n    <li><a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/util\/IdentityHashMap.html\">IdentityHashMap<\/a>\n    <li><a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/util\/LinkedHashMap.html\">LinkedHashMap<\/a>\n    <li><a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/util\/WeakHashMap.html\">WeakHashMap<\/a>\n    <li><a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/util\/TreeMap.html\">TreeMap<\/a>\n    <\/ul>\n\n    <h2>Risks and Remediation<\/h2>\n\n    <p>To avoid undefined behaviour, it is important that non\n    threadsafe collections are consistently guarded by a common lock\n    if they can be read or written concurrently. This means, for\n    example, that reading from a collection requires synchronization\n    if the collection may be modified concurrently.<\/p>\n\n    <p>The consequences of accessing a collection without correct\n    synchronization vary in severity. If the collection is in an\n    inconsistent state (for example, it if being restructured\n    internally), then the accessing thread may enter an infinite loop,\n    or fail with a <code>RuntimeException<\/code>. The exact\n    consequences depend on the collection, may vary between Java\n    Runtime Environment versions, and are unspecified. Other\n    consequences include using values that are no longer current.<\/p>\n\n    <p>Mixed collection synchronization warnings can be fixed by\n    ensuring that all accesses to the named field are guarded by the\n    same lock.<\/p>"}
,"CCE_SL_INCONSISTENT_COL":{"name":"Inconsistent synchronization of accesses to a collection","category":"Locking","description":"<p>The field contains an array or collection not designed for\n    concurrent access which is usually accessed with a lock held, and\n    is usually, but not always, accessed while holding a lock. The\n    programmer may have intended that all accesses were to be\n    protected by a single lock, but has missed some.<\/p>\n\n    <\/p>If concurrent reads and writes to the referenced object are\n    not synchronized with a common lock, then the program will be\n    prone to data races, and hence data corruption and unpredictable\n    behaviour.<\/p>\n\n    <p>When viewing a finding of this type in Eclipse, it is possible\n    to discover which locks are involved with accesses to this field\n    by using the <strong>Accesses view<\/strong>. The Accesses view can\n    be opened by following the 'Accesses and Locks' link in the detail\n    pane to the right of the ThreadSafe view.<\/p>\n\n    <h2>Details<\/h2>\n\n    <p>This rule looks for non threadsafe collections stored in fields\n    that are usually accessed with synchronization by some lock, but\n    in some places are accessed without synchronization by a lock.<\/p>\n\n    <p>The following code snippet demonstrates an example of a class\n    declaration for which ThreadSafe will warn that the collection\n    stored in the field <code>list<\/code> has been accessed with\n    inconsistent synchronization.<\/p>\n\n    <pre><code>\n      public class Stack {\n\n          private final List&lt;Integer&gt; list = new LinkedList&lt;Integer&gt;();\n\n          public synchronized void push(int value) {\n              list.add(0, value);\n          }\n\n          public synchronized void pop() {\n              list.remove(0);\n          }\n\n          public void peek() {\n              return list.get(0);\n          }\n\n      }\n    <\/code><\/pre>\n\n    <p>The methods <code>push(int value)<\/code> and <code>pop()<\/code>\n    synchronize their accesses to the <code>LinkedList<\/code> in the\n    field <code>list<\/code> by using the intrinsic lock associated\n    with the object instance. However, the method\n    <code>peek()<\/code> does no synchronization, so there is a risk\n    of a data race occuring between the writes to the collection in\n    the first two methods and the read in\n    <code>peek()<\/code>. Concretely, this may result in the internal\n    structure of the linked list becoming corrupted, or\n    <code>peek()<\/code> returning values that are grossly outdated,\n    depending on the exact implementation of the\n    <code>LinkedList<\/code> class and the underlying machine\n    architecture.<\/p>\n\n    <p>ThreadSafe examines all accesses to collections stored in\n    fields, whether they occur within the same class that the field is\n    declared, a subclass of that class, inner or outer classes, or any\n    other class within the set of classes being analyzed. Accesses to\n    collections stored in fields that are only reachable from instance\n    or class initializers are discounted as they are unlikely to be\n    executed concurrently with other method invocations on the same\n    object.<\/p>\n\n    <p>An access is regarded as synchronized if it occurs either while\n    an intrinsic lock is held (via use of the\n    <code>synchronized<\/code> keyword), or if a first-class\n    <code>java.util.concurrent.locks.Lock<\/code> has been acquired and\n    not yet released.<\/p>\n\n    <p>To determine whether or not a field may contain a non\n    threadsafe collection, ThreadSafe looks at the classes of object\n    that may be stored in the field, as well as the declared type of\n    the field. In the example above, the field <code>list<\/code> is\n    declared as type <code>List&lt;Integer&gt;<\/code>, which could\n    potentially be a threadsafe collection, such as\n    <code>CopyOnWriteArrayList<\/code>. However, ThreadSafe also sees\n    that the field has been assigned a <code>LinkedList<\/code>\n    instance. Since the class <code>LinkedList<\/code> is not designed\n    to be threadsafe, an inconsistent collection synchronization\n    warning is generated.<\/p>\n\n    <p>This rule applies to many of the collections in the java.util\n    package. The following is an excerpt from the Java API\n    documentation for <a\n    href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/util\/LinkedList.html\"\n    >LinkedList<\/a>:<\/p>\n\n    <blockquote style=\"background-color: #ddd;\">\n\n      <p><strong>Note that this implementation is not\n      synchronized.<\/strong> If multiple threads access a linked list\n      concurrently, and at least one of the threads modifies the list\n      structurally, it <i>must<\/i> be synchronized externally.  (A\n      structural modification is any operation that adds or deletes\n      one or more elements; merely setting the value of an element is\n      not a structural modification.)  This is typically accomplished\n      by synchronizing on some object that naturally encapsulates the\n      list.\n\n      If no such object exists, the list should be \"wrapped\" using the\n      <a\n      href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/util\/Collections.html#synchronizedList(java.util.List)\"\n      ><code>Collections.synchronizedList<\/code><\/a> method.  This is\n      best done at creation time, to prevent accidental unsynchronized\n      access to the list:<pre> List list =\n      Collections.synchronizedList(new LinkedList(...));<\/pre>\n    <\/blockquote>\n\n    <p>Similar constraints are documented for the following classes:<\/p>\n    <ul style=\"list-style-type: none;\">\n    <li><a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/util\/ArrayList.html\">ArrayList<\/a>\n    <li><a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/util\/LinkedList.html\">LinkedList<\/a>\n    <li><a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/util\/HashSet.html\">HashSet<\/a>\n    <li><a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/util\/TreeSet.html\">TreeSet<\/a>\n    <li><a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/util\/EnumMap.html\">EnumMap<\/a>\n    <li><a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/util\/HashMap.html\">HashMap<\/a>\n    <li><a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/util\/IdentityHashMap.html\">IdentityHashMap<\/a>\n    <li><a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/util\/LinkedHashMap.html\">LinkedHashMap<\/a>\n    <li><a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/util\/WeakHashMap.html\">WeakHashMap<\/a>\n    <li><a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/util\/TreeMap.html\">TreeMap<\/a>\n    <\/ul>\n\n    <h2>Risks and Remediation<\/h2>\n\n    <p>To avoid undefined behaviour, it is important that non\n    threadsafe collections are consistently guarded if they can be\n    read or written concurrently. This means, for example, that\n    reading from a collection requires synchronization if the\n    collection may be modified concurrently.<\/p>\n\n    <p>The consequences of accessing a collection without correct\n    synchronization vary in severity. If the collection is in an\n    inconsistent state (for example, it if being restructured\n    internally), then the accessing thread may enter an infinite loop,\n    or fail with a <code>RuntimeException<\/code>. The exact\n    consequences depend on the collection, may vary between Java\n    Runtime Environment versions, and are unspecified. Other\n    consequences include using values that are no longer current.<\/p>\n\n    <p>Inconsistent collection synchronization warnings can be fixed\n    by ensuring that all accesses to the named field are guarded by\n    the same lock.<\/p>"}
,"CCE_CC_GUARD_USAGE":{"name":"Threadsafe collection consistently guarded","category":"Collections","description":"<p>This field contains a collection that has been designed for\n    concurrent usage, but it appears that all the accesses to the\n    collection are protected by a common lock.<\/p>\n\n    <p>Occurences of this finding type do not necessarily mean that\n    the code is in error, but that there might be opportunity for\n    performance improvement or better design by removing unnecessary\n    synchronization.<\/p>\n\n    <p>If a collection is consistently guarded with a lock, then there\n    can be no concurrent access to that collection (due to mutual\n    exclusion). A concurrent collection could therefore safely be\n    replaced with a non-concurrent equivalent. Alternatively, a better\n    locking strategy (for example, the use of putIfAbsent) could allow\n    for locking to be removed, potentially giving better concurrent\n    performance.<\/p>\n\n    <p>Care should be taken when removing synchronization,\n    however. Some collections are designed so that their methods may\n    be invoked concurrently, but the application may require\n    higher-level atomicity guarantees that are not provided by the\n    concurrent collection implementation.<\/p>\n\n    <h2>Details<\/h2>\n\n    <p>This rules looks for threadsafe collections that are stored in\n    a field, where the field is always accessed with locks held.<\/p>\n\n    <p>The following code snippet demonstrates an example of a class\n    declaration for which ThreadSafe will warn that the collection\n    stored in the field <code>list<\/code> is consistently\n    synchronized.<\/p>\n\n    <pre><code>\n      public class Stack {\n\n          private final List&lt;Integer&gt; list = new CopyOnWriteArrayList&lt;Integer&gt;();\n\n          public synchronized void push(int value) {\n              list.add(0, value);\n          }\n\n          public synchronized void pop() {\n              list.remove(0);\n          }\n\n          public synchronized void peek() {\n              return list.get(0);\n          }\n\n      }<\/code><\/pre>\n\n    <p>The methods <code>push(int value)<\/code>, <code>pop()<\/code>\n    and <code>peek()<\/code> synchronize their accesses to the\n    <code>CopyOnWriteArrayList<\/code> in the field\n    <code>list<\/code>. However, this synchronization is unnecessary,\n    because instances of <code>CopyOnWriteArrayList<\/code> are\n    designed to be used concurrently. The unnecessary synchronization\n    on these three methods has no other effect than to introduce\n    overhead, and to reduce performance.<\/p>\n\n    <p>ThreadSafe examines all accesses to collections stored in\n    fields, whether they occur within the same class that the field is\n    declared, a subclass of that class, inner or outer classes, or any\n    other class within the set of classes being analyzed. Accesses to\n    collections stored in fields that are only reachable from instance\n    or class initializers are discounted as they are unlikely to be\n    executed concurrently with other method invocations on the same\n    object.<\/p>\n\n    <p>An access is regarded as synchronized if it occurs either while\n    an intrinsic lock is held (via use of the\n    <code>synchronized<\/code> keyword), or if a first-class\n    <code>java.util.concurrent.locks.Lock<\/code> has been acquired and\n    not yet released.<\/p>\n\n    <p>To determine whether or not a field may contain a threadsafe\n    collection, ThreadSafe looks at the classes of object that may be\n    stored in the field, as well as the declared type of the field. In\n    the example above, the field <code>list<\/code> is declared as type\n    <code>List&lt;Integer&gt;<\/code>, which could potentially be a non\n    threadsafe collection, such as <code>LinkedList<\/code>. However,\n    ThreadSafe also sees that the field has been assigned a\n    <code>CopyOnWriteArrayList<\/code> instance. Since the class\n    <code>CopyOnWriteArrayList<\/code> is designed to be threadsafe, a\n    threadsafe collection consistently guarded warning is\n    generated.<\/p>\n\n    <h2>Risks and Remediation<\/h2>\n\n    <p>As stated above, violations of this rule do not necessarily\n    indicate that there is a defect in the code. However, excessive\n    use of synchronization where it is not needed may indicate\n    unnecessarily poor performance, or poor design.<\/p>\n\n    <p>As stated above, care should be taken when removing\n    synchronization. Some collections are designed so that their\n    methods may be invoked concurrently, but the application may\n    require higher-level atomicity guarantees that are not provided by\n    the concurrent collection implementation. An example of usage of a\n    concurrent collection that is technically threadsafe, but does not\n    give the atomicity guarantees required by the application is the\n    get, check and put pattern when performed without\n    synchronization. For example, consider the following code\n    snippet.<\/p>\n\n<code><pre>\n      public Cache getCache(Long cacheId) {\n          \/\/ get\n          Cache cache = caches.get(cacheId);\n          \/\/ check\n          if (cache == null) {\n              cache = new Cache();\n              \/\/ put\n              caches.put(cacheId, cache);\n          }\n          return cache;\n      }\n<\/pre><\/code>\n\n     <p>If the field <code>caches<\/code> contains a\n     <code>ConcurrentHashMap<\/code> then the <code>get<\/code> and\n     <code>put<\/code> method calls will not cause data races. However,\n     the programmer likely intends that the entire get-check-put\n     sequence will happen atomically, and so ought to be synchronized\n     using a lock.<\/p>\n\n     <p>ThreadSafe's \"Non atomic Check\/Put on threadsafe collection\"\n     and \"Non atomic use of Get\/Check\/Put\" rules can discover cases\n     where there is missing synchronization around sequences of\n     operations that look like they are intended to be performed\n     atomically.<\/p>"}
,"CCE_CC_UNSAFE_CONTENT":{"name":"Shared non threadsafe content","category":"Collections","description":"<p>This threadsafe collection may contain collections\n    that are not threadsafe, which seems to allow unsafe sharing.<\/p>\n\n    <h2>Details<\/h2>\n\n    <p>If a non threadsafe collection is stored inside a threadsafe\n    collection, two threads could potentially get access to the\n    non threadsafe collection and access it concurrently. For example:<\/p>\n\n    <pre><code>\n      class Listeners {\n          private ConcurrentMap&lt;Long, List&lt;Listener&gt;&gt; listeners =\n              new ConcurrentHashMap&lt;Long, List&lt;Listener&gt;&gt;();\n\n          public void addListener(Long id, Listener l) {\n              List&lt;Listener&gt; ls =\n                  listeners.putIfAbsent(id, new ArrayList&lt;Listener&gt;());\n              ls.add(l);\n          }\n      }\n    <\/code><\/pre>\n\n    <p>In this case, if two threads concurrently call\n    <code>addListener(..)<\/code> with the same <code>id<\/code>\n    argument, the two threads could get access to the same\n    <code>ArrayList<\/code> object. This could result in the\n    <code>ArrayList<\/code> being concurrently modified, resulting in\n    undefined behaviour.<\/p>\n\n    <p>This is not just a problem for concurrent writes. If a\n    <code>HashMap<\/code> is read while it is being concurrently\n    altered, it may seem that the worst that can happen is that the\n    reader sees an outdated value. However, this can (and often does)\n    lead to an infinite loop!<\/p>"}
,"CCE_CC_SUGGEST_PUTIFABSENT":{"name":"Get\/check\/put used rather than putIfAbsent","category":"Collections","description":"<p>The program uses a get\/check\/put pattern on a threadsafe\n    <code>Map<\/code> implementation that could be replaced by a\n    <code>putIfAbsent<\/code>.<\/p>\n\n    <p>The get\/check\/put pattern that is often used with Map objects\n    may sometimes be replaced by ConcurrentMap.putIfAbsent, which\n    often offers better concurrent performance. The following code is\n    an example of the get\/check\/put pattern:<\/p>\n\n    <pre><code>\n      public synchronized Cache getCache(Long cache_id) {\n          \/\/ get\n          Cache cache = caches.get(id);\n          \/\/ check\n          if (cache == null) {\n              cache = new Cache();\n              \/\/ put\n              caches.put(cache_id, cache);\n          }\n          return cache;\n      }\n    <\/code><\/pre>\n\n    <p>The above method is synchronized to ensure that the get, check\n    and put operations happen atomically. The cache is only created if\n    necessary.  However, the synchronization may cause performance\n    problems if there is contention for the lock.<\/p>\n\n    <p>It is possible to avoid the synchronization in the code above,\n    which may allow a greater degree of concurrency. If it is\n    permissible to create new Cache instances regardless of whether\n    they are required, the following alternative may improve\n    performance by reducing contention on the object used as a lock\n    for synchronization:<\/p>\n\n    <pre><code>\n      public Cache getCache(Long cacheId) {\n          Cache cache = new Cache();\n          Cache existing = caches.putIfAbsent(cacheId, cache);\n          if (existing != null) {\n              cache = existing;\n          }\n          return cache;\n      }\n    <\/code><\/pre>\n\n    <p>However, this always instantiates a new Cache object, even when\n    one already exists. A more complicated, but smarter way that only\n    instantiates a new Cache when it may be necessary is:<\/p>\n\n    <pre><code>\n      public Cache getCache(Long cacheId) {\n          Cache cache = caches.get(cacheId);\n          if (cache == null) {\n              cache = new Cache();\n              Cache existing = caches.putIfAbsent(cacheId, cache);\n              if (existing != null) {\n                  cache = existing;\n              }\n          }\n          return cache;\n      }\n    <\/code><\/pre>\n\n    <p>With this, <code>putIfAbsent<\/code> is only called if there may\n    not be a cache already associated with the\n    <code>cacheId<\/code>. The call to putIfAbsent is still necessary,\n    as two threads may concurrently enter the if block.<\/p>"}
,"CCE_CC_NON_ATOMIC_CP":{"name":"Non atomic Check\/Put on threadsafe collection","category":"Collections","description":"<p>An object is added to a threadsafe collection after querying\n      its contents, but no lock covers both method calls.<\/p>\n\n      <p>For example, the following code erroneously attempts to\n      ensure a collection contains a single instance of a given object\n      by checking whether the object is already in the collection, and\n      adding it if it is not:<\/p>\n\n      <pre><code>\n      class ListWrapper {\n          private List&lt;Object&gt; list = new CopyOnWriteArrayList&lt;Object&gt;();\n\n          public void ensurePresent(Object o) {\n              if (!list.contains(o)) {\n                  list.add(o);\n              }\n           }\n      }\n      <\/code><\/pre>\n\n      <p>If two concurrent threads call <code>ensurePresent(..)<\/code>\n      with the same object, the object may be added to the list\n      twice.<\/p>\n\n      <p>While the individual check and put methods are threadsafe,\n      the two operations together may not be performed atomically.\n      After the check method has been called, but before the put\n      method is called, another thread may have modified the\n      collection and invalidated the check.<\/p>"}
,"CCE_CC_NON_ATOMIC_GCP":{"name":"Non atomic use of Get\/Check\/Put","category":"Collections","description":"<p>The code uses a get\/check\/put pattern on a threadsafe map, but\n    no lock covers these operations.<\/p>\n\n    <p>If no lock is held throughout a get\/check\/put operation, then\n    these operations may be interleaved by concurrent threads, leading\n    to unintended behaviour. For example:<\/p>\n\n    <pre><code>\n      public Cache getCache(Long cacheId) {\n          \/\/ get\n          Cache cache = caches.get(cacheId);\n          \/\/ check\n          if (cache == null) {\n              cache = new Cache();\n              \/\/ put\n              caches.put(cacheId, cache);\n          }\n          return cache;\n      }\n    <\/code><\/pre>\n\n    <p>Imagine there are two threads, A and B, that call\n    <code>getCache(..)<\/code> concurrently with the same\n    <code>cacheId<\/code>. First, A calls\n    <code>caches.get(cacheId)<\/code>, and gets <code>null<\/code>, as\n    there is no <code>Cache<\/code> object yet associated with the\n    <code>cacheId<\/code>. B then does the same, also receiving\n    <code>null<\/code>. Now, both A and B will create separate\n    <code>Cache<\/code> objects, insert them into the\n    <code>caches<\/code> map, and return them. However, A and B have\n    now got different Cache objects for the same <code>cacheId<\/code>,\n    which is not what was intended.<\/p>\n\n    <p>One solution to this problem would be to synchronize the\n    <code>getCache<\/code> method, ensuring that threads A and B cannot\n    call it concurrently. A shorter and potentially more performant\n    (due to the lack of lock) solution may be:<\/p>\n\n    <pre><code>\n      public Cache getCache(Long cacheId) {\n          Cache cache = new Cache();\n          Cache existing = caches.putIfAbsent(cacheId, cache);\n          if (existing != null) {\n              cache = existing;\n          }\n          return cache;\n      }\n    <\/code><\/pre>\n\n    <p>However, this always instantiates a new <code>Cache<\/code>\n    object, even when one already exists. A more complicated, but\n    smarter way that only instantiates a new <code>Cache<\/code> when\n    it may be necessary is:<\/p>\n\n    <pre><code>\n     public Cache getCache(Long cacheId) {\n         Cache cache = caches.get(cacheId);\n         if (cache == null) {\n             cache = new Cache();\n             Cache existing = caches.putIfAbsent(cacheId, cache);\n             if (existing != null) {\n                 cache = existing;\n             }\n         }\n         return cache;\n     }\n    <\/code><\/pre>\n\n    <p>With this, <code>putIfAbsent<\/code> is only called if there may\n    not be a <code>Cache<\/code> object already associated with the\n    <code>cacheId<\/code>. The <code>putIfAbsent<\/code> call is still\n    necessary, as two threads may concurrently enter the then-part of\n    the <code>if<\/code> block.<\/p>"}
,"CCE_CC_UNSAFE_REPLACEMENT":{"name":"Threadsafe collection replaced by potentially unsafe collection","category":"Collections","description":"<p>The field is assigned both threadsafe and non threadsafe\n    collections.<\/p>\n\n    <p>The assignment of a threadsafe collection creates the\n    impression that a field is intended to be threadsafe. If a\n    potentially non threadsafe collection subsequently replaces the\n    threadsafe collection, this may be an error. For example:<\/p>\n\n    <pre><code>\n      interface ListProvider {\n          List&lt;Object&gt; getList();\n      }\n\n      class ListWrapper {\n          private List&lt;Object&gt; l = new CopyOnWriteArrayList&lt;Object&gt;();\n\n          public void init(ListProvider provider) {\n              l = provider.getList();\n          }\n          ...\n      }\n    <\/code><\/pre>\n\n    <p>In this case, the field <code>l<\/code> is initially assigned to\n    a threadsafe list type.  However, when the object is initialised,\n    the threadsafe value is replaced by a potentially non threadsafe\n    <code>List<\/code> object. If a <code>ListProvider<\/code> that\n    provides a non threadsafe <code>List<\/code> implementation (such\n    as <code>ArrayList<\/code>) is used, then if <code>l<\/code> is\n    assumed to reference a threadsafe object, concurrency problems\n    could arise.<\/p>"}
,"CCE_LK_REPLACE_WITH_TRYLOCK":{"name":"Use of isLocked() and lock() rather tryLock()","category":"Locking","description":"<p>The code calls isLocked() followed by lock() on a Lock\n      object. It may be more appropriate to replace the two calls with\n      a single call to tryLock().<\/p>\n\n      <p>Code that conditionally acquires a lock based on the result\n      of a call to isLocked() may indicate an erroneous attempt to\n      acquire a lock if and only if it can be acquired immediately\n      without blocking.<\/p>\n\n      <p>If two threads call isLocked() concurrently, and observe that\n      the lock has not been taken, they may both attempt to acquire\n      the lock simultaneously.  This could cause one thread to block\n      while it waits for the other thread to release the lock, because\n      only one thread can hold a given lock at any time. This may not\n      be the intended behaviour.<\/p>\n\n      <p>Consider replacing the calls to isLocked() and lock() with a\n      single call to tryLock(). The tryLock() method attempts to\n      acquire the lock without blocking. If it succeeds, it returns\n      true and the current thread holds the lock. If the lock cannot\n      be acquired immediately, then the method returns false and the\n      current thread does not hold the lock.<\/p>\n\n      <p>As tryLock() is a single atomic operation, there is no chance\n      for another thread to acquire the lock between the call to\n      isLocked() and the call to lock().<\/p>\n\n      <p>For example, the following code contains calls to isLocked()\n      and lock():<\/p>\n\n      <pre>\n      private final ReentrantLock lock = new ReentrantLock();\n\n      public void updateIfLockAvailable() {\n          if (!lock.isLocked()) {\n              lock.lock();\n              try {\n                  \/\/ Do something with the lock held.\n              } finally {\n                  lock.unlock();\n              }\n          }\n      }\n      <\/pre>\n\n      <p>The code above is better written using tryLock(), as\n      follows:<\/p>\n\n      <pre>\n      private final ReentrantLock lock = new ReentrantLock();\n\n      public void updateIfLockAvailable() {\n          if (lock.tryLock()) {\n              try {\n                  \/\/ Do something with the lock held.\n              } finally {\n                  lock.unlock();\n              }\n          }\n      }\n      <\/pre>"}
,"CCE_LK_LOCKED_BLOCKING_CALLS":{"name":"Call to blocking method while holding lock","category":"Locking","description":"<p>This call to a BlockingQueue method may cause a deadlock,\n      because a lock is held that may prevent the method from\n      returning. For example:<\/p>\n\n      <pre>\n      public class CustomQueue {\n          private ArrayBlockingQueue q = new ArrayBlockingQueue(100);\n\n          public synchronized void put(Object x) {\n              q.put(x);\n          }\n\n          public synchronized Object get() {\n              return q.poll();\n          }\n      }\n      <\/pre>\n\n      When put is called on a CustomQueue that has reached its maximal\n      capacity, then this put operation will deadlock and wait\n      forever. A call to get will not alleviate the problem, because\n      before get can actually be executed, it has to obtain the lock\n      of the CustomQueue, which is impossible, as that lock is\n      currently held by the put operation."}
,"CCE_BC_CONCURRENT_MODIFICATION":{"name":"ConcurrentModificationException caught","category":"Bad Practice","description":"<p>The code catches\n      <code>ConcurrentModificationException<\/code>. This may indicate\n      code that works around a concurrency bug instead of fixing the\n      underlying problem.<\/p>\n\n      <h2>Details<\/h2>\n\n      <p>This rule looks for places where the code explicitly catches\n      <code>ConcurrentModificationException<\/code>s. An example that\n      is caught by this rule is shown in the following code\n      snippet:<\/p>\n\n      <pre><code>\n          public void add(Object x) {\n              try {\n                  list.add(x);\n              } catch (ConcurrentModificationException ex) {\n                  ex.printStackTrace();\n              }\n          }\n      <\/code><\/pre>\n\n      <p>ThreadSafe will highlight the line <code>catch (..) {<\/code>\n      as a place where <code>ConcurrentModificationException<\/code>s\n      are explicitly caught. There is often nothing useful that can be\n      done when such execptions occur, and they often cover up\n      underlying design errors in the program.<\/p>"}
,"CCE_CC_UNSAFE_ITERATION":{"name":"Unsafe iteration over synchronized collection","category":"Collections","description":"<p>The code iterates over a synchronized collection without\n      holding a lock on the collection.<\/p>\n\n      <p>Iteration over synchronized collections (such as\n      <code>Vector<\/code>, or collections returned by methods such as\n      <code>Collections.synchronizedMap<\/code>) should be synchronized\n      on the collection object. This rule checks for places where\n      iterators are created and used without correct\n      synchronization.<\/p>\n\n      <h2>Details<\/h2>\n\n      <p>An example of iterating over a synchronized collection\n      without the correct synchronization is shown in the following\n      code snippet:<\/p>\n\n      <pre><code>\n      public class UnsafeIteration {\n\n          \/\/ Synchronized collection\n          private List<String> list =\n              Collections.synchronizedList(new ArrayList<String>());\n\n          public void iterateOverList() {\n              \/\/ Iteration over a synchronized collection without holding a\n              \/\/ lock on the collection.\n              for (String item : list) {\n                  System.out.println(item);\n              }\n          }\n\n      }\n      <\/code><\/pre>\n\n      <p>The field <code>list<\/code> contains a synchronized\n      collection, created using the\n      <code>Collections.synchronizedList(..)<\/code> method. This\n      object can be safely mutated and observed concurrently by\n      multiple threads. All accesses are synchronized using the\n      intrinsic lock associated with the object. However, since\n      iteration over the collection is a non-atomic operation, it is\n      the client's responsibility to synchronize on <code>list<\/code>\n      while iterating over the elements.<\/p>\n\n      <p>Failure to correct synchronize means that the collection may\n      be modified by a thread while another thread is iterating over\n      the elements. The results of doing so are undefined, and can, in\n      the worst case, lead to bad behaviour such as infinite loops due\n      to mutating threads altering the internal structure of the\n      collection.<\/p>\n\n      <p>The correct implementation of the\n      <code>iterateOverList<\/code> is as follows:<\/p>\n\n      <pre><code>\n          public void iterateOverList() {\n              synchronized (list) {\n                  \/\/ Iteration over a synchronized collection without holding a\n                  \/\/ lock on the collection.\n                  for (String item : list) {\n                      System.out.println(item);\n                  }\n              }\n          }\n      <\/code><\/pre>\n\n      <p>In this corrected code, a <code>synchronized<\/code> block has\n      been used to synchronize on the intrinsic lock associated with\n      the object referenced by the <code>list<\/code> field, making\n      sure that concurrent modifications of the collection do not\n      occur during iteration.<\/p>"}
,"CCE_CC_CALLBACK_ACCESS":{"name":"Unsynchronized access to field from asynchronously invoked method","category":"Locking","description":"<p>A field, or collection stored in a field, is modified from an\n    asynchronously invoked method without proper synchronization.<\/p>\n\n    <p> If concurrent reads and writes are not synchronized with a\n    common lock, then the program will be prone to data races, data\n    corruption and unpredictable behaviour.<\/p>\n\n    <p>When viewing a finding of this type in Eclipse, it is possible\n    to discover which locks, if any, are involved with accesses to the\n    collection stored in this field by using the <strong>Accesses\n    view<\/strong>. The Accesses view can be opened by following the\n    'Accesses and Locks' link in the detail pane to the right of the\n    ThreadSafe view.<\/p>\n\n    <h2>Details<\/h2>\n\n    <p>This rule looks for fields, or collections that are stored in\n    fields, that are accessed from asynchronously invoked methods\n    without synchronization. Asynchronously invoked methods include\n    the <code>run()<\/code> methods of <code>Runnable<\/code> instances\n    used as threads or as background tasks, and also\n    <code>doInBackground()<\/code> methods used for\n    <code>AsyncTask<\/code>s in the Android framework.<\/p>\n\n    <p>The following code snippet demonstrates an example of a class\n    declaration for which ThreadSafe will warn that the field\n    <code>currentRates<\/code> has been accessed from an asynchronously\n    invoked method without synchronization.<\/p>\n\n<pre><code>\n      public class AsynchronousMethodExample {\n\n          private ConcurrentMap&lt;Long, Double&gt; currentRates;\n\n          public Example() {\n              new Timer().scheduleAtFixedRate(new TimerTask () {\n                  public void run() {\n                      \/\/ Update the current rates every so often.\n                      currentRates = Rates.getCurrent();\n                  }\n              }, 10000, 10000);\n              currentRates = Rates.getCurrent();\n          }\n\n          public double getRate(int id) {\n              return currentRates.get(id);\n          }\n      }\n<\/code><\/pre>\n\n    <p>The field <code>currentRates<\/code> is being updated in the\n    <code>run()<\/code> method of the anonymous inner class being used\n    as a <code>TimerTask<\/code>. Meanwhile, the <code>getRate()<\/code>\n    method is reading this field. The update occurs in a background\n    thread started by the <code>Timer<\/code> object, while the read\n    would likely occur in another thread. The two methods do not\n    synchronize their accesses, which means there is no guarantee that\n    the reading thread would see the currentRates field in a\n    consistent state.<\/p>\n\n    <p>ThreadSafe examines all accesses to fields, and collections\n    stored in fields, whether they occur within the same class that\n    the field is declared, a subclass of that class, inner or outer\n    classes, or any other class within the set of classes being\n    analyzed. Accesses to collections stored in fields that are only\n    reachable from instance or class initializers are discounted as\n    they are unlikely to be executed concurrently with other method\n    invocations on the same object.<\/p>\n\n    <p>ThreadSafe determines that a method may be invoked\n    asynchronously either by looking for methods that are\n    implementations of methods that are likely to be called\n    asynchronously, for example <code>TimerTask.run()<\/code> or\n    <code>AsyncTask.doInBackground()<\/code>, or by looking for\n    <code>Runnable<\/code> implementations that are used as\n    threads. Presently, ThreadSafe understands implementations of the\n    following methods as potential asynchronous callback methods:<\/p>\n\n    <ul>\n      <li><code>TimerTask.run()<\/code>;<\/li>\n      <li><code>AsyncTask.doInBackground()<\/code> in Android applications; and<\/li>\n      <li><code>IntentService.onHandleIntent()<\/code> in Android applications.<\/li>\n    <\/ul>\n\n    <p>Instances of callback classes are usually passed to another\n    class so that their methods may be called when interesting events\n    happen. These callbacks may happen asynchronously on a background\n    thread, in which case the programmer must be careful to correctly\n    synchronize when accessing shared data.<\/p>\n\n    <p>If ThreadSafe discovers a pair of accesses to a field, or\n    collection stored in field, with no synchronization, and where one\n    of the methods is invoked asynchronously, a warning of this type\n    is generated.<\/p>\n\n    <p>An access is regarded as synchronized if it occurs either while\n    an intrinsic lock is held (via use of the\n    <code>synchronized<\/code> keyword), or if a first-class\n    <code>java.util.concurrent.locks.Lock<\/code> has been acquired and\n    not yet released.<\/p>\n\n    <p>To determine whether or not a field may contain a non\n    threadsafe collection, ThreadSafe looks at the classes of object\n    that may be stored in the field, as well as the declared type of\n    the field.<\/p>\n\n    <p>This rule applies to many of the collections in the java.util\n    package. The following is an excerpt from the Java API\n    documentation for <a\n    href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/util\/LinkedList.html\"\n    >LinkedList<\/a>:<\/p>\n\n    <blockquote style=\"background-color: #ddd;\">\n\n      <p><strong>Note that this implementation is not\n      synchronized.<\/strong> If multiple threads access a linked list\n      concurrently, and at least one of the threads modifies the list\n      structurally, it <i>must<\/i> be synchronized externally.  (A\n      structural modification is any operation that adds or deletes\n      one or more elements; merely setting the value of an element is\n      not a structural modification.)  This is typically accomplished\n      by synchronizing on some object that naturally encapsulates the\n      list.\n\n      If no such object exists, the list should be \"wrapped\" using the\n      <a\n      href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/util\/Collections.html#synchronizedList(java.util.List)\"\n      ><code>Collections.synchronizedList<\/code><\/a> method.  This is\n      best done at creation time, to prevent accidental unsynchronized\n      access to the list:<pre> List list =\n      Collections.synchronizedList(new LinkedList(...));<\/pre>\n    <\/blockquote>\n\n    <p>Similar constraints are documented for the following classes:<\/p>\n    <ul style=\"list-style-type: none;\">\n    <li><a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/util\/ArrayList.html\">ArrayList<\/a>\n    <li><a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/util\/LinkedList.html\">LinkedList<\/a>\n    <li><a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/util\/HashSet.html\">HashSet<\/a>\n    <li><a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/util\/TreeSet.html\">TreeSet<\/a>\n    <li><a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/util\/EnumMap.html\">EnumMap<\/a>\n    <li><a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/util\/HashMap.html\">HashMap<\/a>\n    <li><a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/util\/IdentityHashMap.html\">IdentityHashMap<\/a>\n    <li><a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/util\/LinkedHashMap.html\">LinkedHashMap<\/a>\n    <li><a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/util\/WeakHashMap.html\">WeakHashMap<\/a>\n    <li><a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/util\/TreeMap.html\">TreeMap<\/a>\n    <\/ul>\n\n    <h2>Risks and Remediation<\/h2>\n\n    <p>To avoid undefined behaviour, it is important that fields and\n    non threadsafe collections are consistently guarded if they may be\n    read or written concurrently. This means, for example, that\n    reading from a collection requires synchronization if the\n    collection may be modified concurrently.<\/p>\n\n    <p>The consequences of accessing a collection without correct\n    synchronization vary in severity. If the collection is in an\n    inconsistent state (for example, it if being restructured\n    internally), then the accessing thread may enter an infinite loop,\n    or fail with a RuntimeException. The exact consequences depend on\n    the collection, may vary between Java Runtime Environment\n    versions, and are unspecified. Other consequences include using\n    values that are no longer current.<\/p>\n\n    <p>Unsynchronized accesses to fields from asynchronously invoked\n    method warnings can be fixed by ensuring that all accesses to the\n    named field are guarded by a common lock.<\/p>"}
,"CCE_CC_FIELD_LOCK_WRITE":{"name":"Field reassigned while holding a lock on its value","category":"Locking","description":"<p>The field is reassigned while holding a lock on its current\n      value.<\/p>\n\n      <p>A value is assigned to a field while holding the intrinsic\n      lock on the previous value of that field. This may indicate that\n      the wrong field is used for locking, or that an incorrect\n      locking strategy is being used.<\/p>\n\n      <h2>Details<\/h2>\n\n      <p>In the code below, a field called <code>name<\/code> is\n      reassigned by the <code>setName(..)<\/code> method, which\n      acquires a lock on that field before reassigning it. A field\n      called <code>version<\/code> is used in attempt to count the\n      number of times the name field is updated. However, the\n      implementation is incorrect:<\/p>\n\n<pre><code>\n      public class FieldLockReassignedExample {\n\n          private String name = \"\";\n\n          private int version = 0;\n\n          public void setName(String newName) {\n              synchronized (name) {\n                  name = newName;\n                  version++;\n              }\n          }\n\n      }\n<\/code><\/pre>\n\n      <p>If two threads call <code>setName()<\/code> concurrently, the\n      increments performed on the <code>version<\/code> field will be\n      part of a datarace, and the resulting values of the\n      <code>version<\/code> field observed by both threads will likely\n      not be what the programmer intended. If the one thread acquires\n      an intrinsic lock on the initial value (the empty string), and\n      the other thread acquires an intrinsic lock on the value set by\n      the first thread, then each thread will be using a different\n      lock object. This leads to a datarace as both threads read,\n      increment and update the version number.<\/p>\n\n      <h2>Risks and Remediation<\/h2>\n\n      <p>Reassignment of a field while holding the intrinsic lock on\n      the field's value may indicate a lock on the wrong value is\n      being acquired. It may also indicate a misconception that a lock\n      is associated with the field itself, rather than the value it\n      references.<\/p>\n\n      <p>When fixing an instance where a field containing a lock has\n      been overwritten, care must be taken to ensure that the\n      synchronization that is performed by the program is sufficient\n      in order to guarantee the application level behaviour that is\n      desired. In many cases, creating a new final field which\n      contains the object to be used for synchronization is the\n      correct way to proceed. When performing such a change, care must\n      be taken to ensure that all occurences of synchronization on the\n      old field are updated to synchronize on the new\n      field.<\/p>"}
,"CCE_CC_REUSEDOBJ_SYNC":{"name":"Synchronizing on reusable objects","category":"Locking","description":"<p>An object which may be cached and reused is used for locking.<\/p>\n\n      <p>Synchronizing on objects which may be reused, such as boxed\n      primitives, can cause non-deterministic behaviour. Synchronizing\n      on such reusable objects should be avoided. Examples of reusable\n      objects include auto-boxed primitive types and String\n      literals.<\/p>\n\n      <h2>Details<\/h2>\n\n      <p>An example of synchronizing on an object which may be reused\n      is shown below:<\/p>\n\n      <pre><code>\n      private final Boolean init = false;\n\n      public void doSomething() {\n          synchronized (init) {\n              ...\n          }\n      }\n      <\/code><\/pre> \n\n      <p>If a boolean value has been autoboxed then it will reference\n      <code>Boolean.TRUE<\/code> or <code>Boolean.FALSE<\/code>. Thus\n      threads can unintentionally end up synchronizing on the same\n      object.<\/p>\n\n      <p>Here is another example of synchronization on a reusable\n      object, involving the <code>Integer<\/code> class:<\/p>\n\n      <pre><code>\n      private final Integer lock = 1;\n\n      public void doSomething() {\n          synchronized (lock) {\n             ...\n          }\n      }\n      <\/code><\/pre>\n\n      <p>One solution is to use the <code>new<\/code> keyword to avoid\n      locking on an object that might be reused:<\/p>\n\n      <pre><code>\n      private int x = 1;\n      private final Integer lock = new Integer(x);\n\n      public void doSomething() {\n          synchronized (lock) {\n             ...\n          }\n      }\n      <\/code><\/pre>\n\n      <p>A better solution is to lock on a private final lock object:<\/p>\n\n      <pre><code>\n      private final Object lock = new Object();\n\n      public void doSomething() {\n          synchronized (lock) {\n             ...\n          }\n\n      }\n      <\/code><\/pre>\n\n      <p> For further information see the related <a\n      href=\"https:\/\/www.securecoding.cert.org\/confluence\/display\/java\/LCK01-J.+Do+not+synchronize+on+objects+that+may+be+reused\">\n      CERT LCK01-J<\/a> guideline.  <\/p>"}
,"CCE_CC_SYNC_ON_VIEW":{"name":"Synchronizing on a collection view","category":"Collections","description":"<p>The code synchronizes on a synchronized collection view.<\/p>\n\n      <p>Synchronizing on a synchronized collection view is usually\n      the wrong thing to do when no iteration over the view is\n      performed. For example:<\/p>\n\n\n      <pre>\n      private final List&lt;String&gt; list =\n          synchronizedList(new ArrayList&lt;String&gt;());\n\n      private final List&lt;String&gt; tail =\n          list.subList(1, list.size());\n\n      public void synchronizedOnView() {\n          synchronized (tail) {\n              \/\/ Do something with slice (but not iteration)\n          }\n      }\n      <\/pre>\n\n      <p>This pattern is an indicator of poor quality code and can\n      lead to maintenance issues in the future, for example a change\n      to iterate over the collection view in the synchronized block\n      could lead to non-deterministic behaviour.<\/p>\n\n      <p>For more information refer to:\n      <ul>\n      <li><a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/technotes\/guides\/collections\/index.html\">java.util.Collection documentation<\/a><\/li>\n\n      <li>the <a\n      href=\"http:\/\/docs.oracle.com\/javase\/tutorial\/collections\/implementations\/wrapper.html\">Wrapper\n      Implementations<\/a> in the Java Tutorial<\/li>\n\n      <li>The CERT Oracle Secure Coding Standard for Java\n      documentation (Rule <a\n      href=\"https:\/\/www.securecoding.cert.org\/confluence\/display\/java\/LCK04-J.+Do+not+synchronize+on+a+collection+view+if+the+backing+collection+is+accessible\">CERT-LCK04-J<\/a>).<\/li>\n      <\/ul>\n      <\/p>"}
,"CCE_CC_ITER_VIEW_WRONG_LOCK":{"name":"Iteration over collection view while not locking on the backing collection","category":"Collections","description":"<p>The code iterates over a view of a\n      synchronized collection without holding a lock on the backing\n      collection.<\/p>\n\n      <p>A lock should be taken on the synchronized collection when\n      iterating over a view on the collection. Failure to do so can\n      result in non-deterministic behaviour.  For example:<\/p>\n\n      <pre>\n          List&lt;String&gt; syncList =\n              Collections.synchronizedList(new LinkedList&lt;String&gt;());\n\n          public void doTail() {\n              List&lt;String&gt; subList = syncList.subList(1, syncList.size());\n\n              synchronized (subList) {\n                  for (String str : subList) {\n                      \/\/ do something with str\n                  }\n              }\n          }\n      <\/pre>\n\n      <p>The example code above incorrectly synchronizes on the\n      collection view (the local variable subList). The backing\n      synchronized collection is potentially externally visible\n      allowing other threads to access the backing collection and make\n      changes while the lock on the view is held resulting in\n      non-deterministic behaviour while iterating over the collection\n      view.<\/p>\n\n      <p> The correct solution is to synchronize on the backing\n      collection as shown in the example below:<\/p>\n\n      <pre>\n          List&lt;String&gt; syncList =\n              Collections.synchronizedList(new LinkedList&lt;String&gt;());\n\n          public void doTail() {\n              List&lt;String&gt; subList = syncList.subList(1, syncList.size());\n\n              synchronized (syncList) {\n                  for (String str : subList) {\n                      \/\/ do something with str\n                  }\n              }\n          }\n      <\/pre>\n\n      <p>For more information refer to:\n      <ul>\n      <li><a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/technotes\/guides\/collections\/index.html\">java.util.Collection documentation<\/a><\/li>\n\n      <li>the <a\n      href=\"http:\/\/docs.oracle.com\/javase\/tutorial\/collections\/implementations\/wrapper.html\">Wrapper\n      Implementations<\/a> in the Java Tutorial<\/li>\n\n      <li>The CERT Oracle Secure Coding Standard for Java\n      documentation (Rule <a\n      href=\"https:\/\/www.securecoding.cert.org\/confluence\/display\/java\/LCK04-J.+Do+not+synchronize+on+a+collection+view+if+the+backing+collection+is+accessible\">CERT-LCK04-J<\/a>).<\/li>\n      <\/ul>\n      <\/p>"}
,"CCE_CC_ITER_VIEW_NO_LOCK":{"name":"No lock held while iterating on a synchronized collection view","category":"Collections","description":"<p>The code iterates over a view of a synchronized collection\n      without acquiring a lock on the collection.<\/p>\n\n      <p>It is essential to synchronize on the backing collection\n      when iterating over a view of a synchronized collection. For\n      example:<\/p>\n\n      <pre>\n          private final List&lt;String&gt; list =\n              Collections.synchronizedList(new ArrayList&lt;String&gt;());\n\n          private final List&lt;String&gt; slice = list.subList(0, list.size());\n\n          public void doList() {\n              for (String str : slice) {\n                  \/\/ do something with str\n              }\n          }\n      <\/pre> <p>In the example above no lock is protecting the\n      iteration over the sublist view on the synchronized list. A lock\n      should be taken when iterating over a view on a synchronized\n      collection as shown below:<\/p>\n\n      <pre>\n          private final List&lt;String&gt; list =\n              Collections.synchronizedList(new ArrayList&lt;String&gt;());\n\n          private final List&lt;String&gt; slice = list.subList(0, list.size());\n\n          public void doList() {\n              synchronized (list) {\n                  for (String str : slice) {\n                      \/\/ do something with str\n                  }\n              }\n          }\n      <\/pre>\n      <p>For more information refer to:\n      <ul>\n      <li><a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/technotes\/guides\/collections\/index.html\">java.util.Collection documentation<\/a><\/li>\n\n      <li>the <a\n      href=\"http:\/\/docs.oracle.com\/javase\/tutorial\/collections\/implementations\/wrapper.html\">Wrapper\n      Implementations<\/a><\/li>\n\n      <li>The CERT Oracle Secure Coding Standard for Java\n      documentation (Rule <a\n      href=\"https:\/\/www.securecoding.cert.org\/confluence\/display\/java\/LCK04-J.+Do+not+synchronize+on+a+collection+view+if+the+backing+collection+is+accessible\">CERT-LCK04-J<\/a>).<\/li>\n      <\/ul>\n      <\/p>"}
,"CCE_CC_ITER_VIEW_BOTH_LOCKS":{"name":"Iterating over a synchronized collection view while holding a lock on the view","category":"Collections","description":"<p>The code iterates over a view on a\n      synchronized collection while holding locks on both the view\n      and the backing collection.<\/p>\n\n      <p>Iteration over views on synchronized collections require a\n      lock to be taken on the backing collection. An additional\n      lock taken on the view may be unnecessary. For example:<\/p>\n      <pre>\n          private final List&lt;String&gt; list =\n              Collections.synchronizedList(new ArrayList&lt;String&gt;());\n\n          private final List&lt;String&gt; subList = list.subList(0, list.size());\n\n\n          public void doSubList() {\n\n              synchronized (list) {\n                  synchronized (subList) {\n                      for (String str : subList) {\n                          \/\/ do something with str\n                      }\n                  }\n              }\n          }\n      <\/pre>\n\n      <p>In the example above the synchronization on the subList is\n      unnecessary, you should only synchronize on the backing\n      collection as shown below: <\/p>\n\n      <pre>\n          private final List&lt;String&gt; list =\n              Collections.synchronizedList(new ArrayList&lt;String&gt;());\n\n          private final List&lt;String&gt; subList = list.subList(0, list.size());\n\n          public void doSubList() {\n\n              synchronized (list) {\n                  for (String str : subList) {\n                      \/\/ do something with str\n                  }\n              }\n          }\n      <\/pre>\n      <p>For more information refer to:\n      <ul>\n      <li><a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/technotes\/guides\/collections\/index.html\">java.util.Collection documentation<\/a><\/li>\n\n      <li>the <a\n      href=\"http:\/\/docs.oracle.com\/javase\/tutorial\/collections\/implementations\/wrapper.html\">Wrapper\n      Implementations<\/a><\/li>\n\n      <li>The CERT Oracle Secure Coding Standard for Java\n      documentation (Rule <a\n      href=\"https:\/\/www.securecoding.cert.org\/confluence\/display\/java\/LCK04-J.+Do+not+synchronize+on+a+collection+view+if+the+backing+collection+is+accessible\">CERT-LCK04-J<\/a>).<\/li>\n      <\/ul>\n      <\/p>"}
,"CCE_LK_UNRELEASED_ON_EXN":{"name":"Lock not released when method throws an exception","category":"Locking","description":"<p>The method acquires a lock, which it releases when exiting\n      normally, but it is not guaranteed to always release the lock when\n      exiting due to an exception being thrown.<\/p>\n\n      <h2>Details<\/h2>\n\n      <p>The following code snippet illustrates a simple example of\n      locks not being released when a method throws an exception:<\/p>\n\n<pre><code>\n      private final Lock lock = new ReentrantLock();\n\n      public void doTransaction() {\n          lock.lock();\n\n          \/\/ ... code to perform a transation, which may\n          \/\/ throw a RuntimeException ...\n\n          lock.unlock();\n      }\n<\/code><\/pre>\n\n      <p>If the code in between the <code>.lock()<\/code> and\n      <code>.unlock()<\/code> calls throws an exception, then the call\n      to <code>.unlock()<\/code> will never happen, and the current\n      thread will continue to hold <code>lock<\/code>. Now any other\n      thread that attempts to call <code>doTransaction()<\/code> will\n      block, because it will be unable to acquire the lock. Even if\n      the original thread calls <code>doTransaction()<\/code> again, it\n      will never release the first acquisition of the lock. The\n      failure to release the lock correctly prevents any other thread\n      that calls <code>doTransaction()<\/code> from making any progress\n      at all.<\/p>\n\n      <h2>Risks and Remediation<\/h2>\n\n      <p>If locks are not guaranteed to be released, then other\n      threads that are attempting to acquire the same lock will\n      block. This may result in deadlock, where threads are unable to\n      make progress while they wait upon resources acquired by other\n      threads to be released.<\/p>\n\n      <p>The correct way to write the <code>doTransation()<\/code>\n      method is to use a <code>try { ... } finally { ... }<\/code>\n      block to ensure that the lock is always released, even if an\n      exception is thrown. This follows the suggested pattern for\n      using implementations of\n      <code>java.util.concurrent.locks.Lock<\/code> recommended by the\n      <a\n      href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/util\/concurrent\/locks\/Lock.html\">API\n      documentation for the <code>Lock<\/code> interface<\/a>:<\/p>\n\n      <pre><code>\n      public void doTransaction() {\n          lock.lock();\n          try {\n              \/\/ ... code to perform a transation, which may\n              \/\/ throw a RuntimeException ...\n          } finally {\n              \/\/ Always release the lock, no matter how the code\n              \/\/ in the try block terminates.\n              lock.unlock();\n          }\n      }\n      <\/code><\/pre>"}
,"CCE_DL_DEADLOCK":{"name":"Deadlock due to circularity in lock dependencies","category":"Locking","description":"<p>ThreadSafe has detected a circular dependency in the pattern\n      of lock acquisition performed by the program, which leaves the\n      program vulnerable to deadlock.<\/p>\n\n      <h2>Details<\/h2>\n\n      <p>The follow code snippet demonstrates a simplified case of a\n      pair of classes with a deadlock vulnerability, due to a cycle in\n      the lock dependencies between them.<\/p>\n\n      <p>Class <code>Folder<\/code>:<\/p>\n\n      <pre><code>\n      class Folder {\n\n          private int unreadCount;\n\n          private List<Message> messages;\n\n          public synchronized void decrementUnreadCount() {\n              unreadCount--;\n          }\n\n          public synchronized void setAllRead() {\n              for (Message message : messages) {\n                  message.setRead();\n              }\n          }\n\n      }\n      <\/code><\/pre>\n\n      <p>Class <code>Message<\/code>:<\/p>\n\n      <pre><code>\n      class Message {\n\n          private Folder folder;\n\n          private boolean read;\n\n          public synchronized void setRead() {\n              if (!read) {\n                  read = true;\n                  folder.decrementUnreadCount();\n              }\n          }\n      }\n      <\/code><\/pre>\n\n      <p>Suppose that there exists a <code>Folder<\/code> instance and\n      a <code>Message<\/code> instance such that the\n      <code>Message<\/code> instance is contained in the\n      <code>Folder<\/code>'s <code>messages<\/code> list, and the\n      <code>Message<\/code> instance's <code>folder<\/code> field\n      references the <code>Folder<\/code> instance.<\/p>\n\n      <p>If two separate threads invoke the <code>setAllRead()<\/code>\n      method on the <code>Folder<\/code> instance, and the\n      <code>setRead()<\/code> method on the <code>Message<\/code>\n      instance concurrently, then it is possible for the following\n      sequence of events to occur:<\/p>\n\n      <ol>\n\n      <li>The first thread acquires the lock on the\n      <code>Folder<\/code> instance, because the\n      <code>setAllRead()<\/code> method is declared as\n      <code>synchronized<\/code>. The thread then proceeds to work its\n      way along the list of messages, calling <code>setRead()<\/code>\n      on each one.<\/li>\n\n      <li>The second thread acquires the lock on the\n      <code>Message<\/code> instance, because the\n      <code>setRead()<\/code> method is declared as\n      <code>synchronized<\/code>.<\/li>\n\n      <li>The first thread now invokes <code>setRead()<\/code> on the\n      <code>Message<\/code> instance that the second thread has already\n      invoked <code>setRead()<\/code> on. Since this method is declared\n      as <code>synchronized<\/code>, the first thread attempts to\n      acquire a lock on the <code>Message<\/code> instance. It cannot\n      acquire this lock, because the second thread already has\n      it. Therefore, the first thread blocks, waiting for the lock to\n      be released by the second thread.<\/li>\n\n      <li>The second thread invokes the\n      <code>decrementUnreadCount()<\/code> method on the\n      <code>Folder<\/code> instance. Since this method is declared as\n      <code>synchronized<\/code>, the second thread attempts to acquire\n      a lock on the <code>Folder<\/code> instance. It cannot acquire\n      this lock, because the first thread already has it due to\n      <code>setAllRead()<\/code> being declared\n      <code>synchronized<\/code>. The second thread now blocks, waiting\n      for the lock to be released by the first thread.<\/li>\n\n      <\/ol>\n\n      <p>Both of the threads are now blocked, waiting for the other\n      to release the lock they are attempting to acquire. Since\n      neither thread can make any progress, the pair of threads has\n      entered a deadlock situation.<\/p>\n\n      <p>ThreadSafe reports a potential deadlock vulnerability present\n      in the code above, due to the circular dependency between the\n      <code>Folder<\/code> and <code>Message<\/code> classes, and the\n      fact that each calls a method on the other that acquires a lock,\n      while holding a lock.<\/p>\n\n      <h2>Risks and Remediation<\/h2>\n\n      <p>Once two or more threads enter a deadlock situation, the work\n      that was intended to be carried out by the threads will not\n      happen, and the system as a whole will appear to become\n      unresponsive, or will fail to completely carry out some task. A\n      deadlock in one subsystem can cause deadlocks or interruptions\n      in service in other subsystems while they wait forever for\n      deadlocked threads to finish.<\/p>\n\n      <p>Code that is vulnerable to deadlocks can be fixed by ensuring\n      that all locks are acquired in a consistent order, so that there\n      is no possibility of circular dependencies between lock\n      acquisitions. The book <em>Java Concurrency in Practice<\/em> by\n      Goetz <em>et al.<\/em> (Chapter 10) has more information on how\n      write concurrent code that is not vulnerable to deadlocks\n      arising from incorrect use of Java's synchronization\n      primitives.<\/p>"}
,"CCE_RA_GUARDED_BY_VIOLATED":{"name":"GuardedBy annotation violated","category":"Locking","description":"<p>The field's <code>@GuardedBy<\/code> annotation has been\n    violated.<\/p>\n\n    <p>This field has been annotated with a <code>@GuardedBy<\/code>\n    specification describing the lock that should be used to guard all\n    accesses to that field. However, there are cases when the field\n    has been accessed without the lock being held.<\/p>\n\n    <h2>Details<\/h2>\n\n    <p>This rule looks for fields that have been annotated with a\n    <code>@GuardedBy<\/code> specification, but where one or more\n    accesses of that field do not hold the required lock.<\/p>\n\n    <p>The following code snippet demonstrates an example of a class\n    declaration for which ThreadSafe will report that the\n    <code>@GuardedBy<\/code> annotation has been violated:<\/p>\n\n    <pre><code>\n      public class GuardedField {\n\n          @GuardedBy(\"this\")\n          private int value;\n\n          public void writeField(int newValue) {\n              value = newValue;\n          }\n\n      }\n<\/code><\/pre>\n\n    <p>The class <code>GuardedField<\/code> declares a field\n    <code>value<\/code> that has a <code>@GuardedBy<\/code> annotation\n    stating that all accesses to the field must be guarded by first\n    synchronizing on \"<code>this<\/code>\", i.e., the instance\n    containing the field.<\/p>\n\n    <p>The method <code>writeField(int)<\/code> does no\n    synchronization, so ThreadSafe will report that the field\n    <code>value<\/code>'s <code>@GuardedBy<\/code> annotation has been\n    violated.<\/p>\n\n    <p>To fix this warning, the implementation of the\n    <code>writeField(int)<\/code> method should be changed so that it\n    synchronizes on \"<code>this<\/code>\":<\/p>\n\n    <pre><code>\n          public synchronized void writeField(int newValue) {\n              value = newValue;\n          }\n    <\/code><\/pre>\n\n    <p>ThreadSafe understands the following syntax for specifying\n    guards in <code>@GuardedBy<\/code> annotations:<\/p>\n\n    <ul>\n\n      <li><code>\"this\"<\/code>: the annotated field is guarded by a\n      lock held on the enclosing instance.<\/li>\n\n      <li><code>\"fieldName\"<\/code> and <code>\"this.fieldName\"<\/code>:\n      the annotated field is guarded by a lock held on the object\n      referenced by the field <code>fieldName<\/code> in the same\n      instance. If <code>fieldName<\/code> is not a field of reference\n      type (i.e., it is of primitive type: <code>int<\/code>,\n      <code>long<\/code>, <code>float<\/code>, or <code>double<\/code>),\n      then the annotation is invalid. If <code>fieldName<\/code> is of\n      a type that is an implementation of the\n      <code>java.util.concurrent.locks.Lock<\/code> interface, then it\n      is expected that the annotated field is guarded by the use of\n      <code>fieldName.lock()<\/code> instead of\n      <code>synchronized<\/code> blocks.<\/li>\n\n      <li><code>\"C.class\"<\/code>: the annotated field is guarded by a\n      lock held on the class <code>C<\/code>.<\/li>\n\n      <li><code>\"C.fieldName\"<\/code>: the annotated field is guarded\n      by a lock held on the object referenced by the <em>static<\/em>\n      field <code>fieldName<\/code>. If <code>fieldName<\/code> is not a\n      field of reference type (i.e., it is of primitive type:\n      <code>int<\/code>, <code>long<\/code>, <code>float<\/code>, or\n      <code>double<\/code>), then the annotation is invalid. If\n      <code>fieldName<\/code> is of a type that is an implementation of\n      the <code>java.util.concurrent.locks.Lock<\/code> interface, then\n      it is expected that the annotated field is guarded by the use of\n      <code>fieldName.lock()<\/code> instead of\n      <code>synchronized<\/code> blocks.<\/li>\n\n    <\/ul>\n\n    <h2>Risks and Remediation<\/h2>\n\n    <p><code>@GuardedBy<\/code> annotations are used to document the\n    locking strategy used by a class to enable concurrent\n    access. Failure to correctly implement a locking strategy means\n    that instances of this class will act unreliably when used from\n    multiple concurrent threads.<\/p>\n\n    <p>Violations of <code>@GuardedBy<\/code> annotations can be fixed\n    by ensuring that all accesses to the field are guarded by the\n    correct lock.<\/p>"}
,"CCE_RA_GUARD_NOT_FINAL":{"name":"Guard is not final","category":"Locking","description":"<p>The field references a field as a lock in a\n      <code>@GuardedBy<\/code> annotation but the referenced field is\n      not declared as <code>final<\/code>.<\/p>\n\n      <p>For a field to be properly guarded, the guard must refer to\n      the same lock object every time that locking occurs. This is\n      enforced by ensuring that any guard fields are final.<\/p>\n\n      <h2>Details<\/h2>\n\n      <p>The following code snippet demonstrates a case where\n      ThreadSafe will report that a field referenced by a\n      <code>@GuardedBy<\/code> annotation is not final:<\/p>\n\n      <pre><code>\n      public class NonFinalGuard {\n\n          @GuardedBy(\"this.lock\")\n          public int guardedField;\n\n          private Object lock = new Object();\n\n      }\n      <\/code><\/pre>\n\n      <p>The field <code>guardedField<\/code> has been annotated with a\n      <code>@GuardedBy<\/code> annotation that references the field\n      <code>lock<\/code> as its guard. However, the field\n      <code>lock<\/code> is not final.<\/p>\n\n      <p>In general, fields that are used to hold objects that will be\n      used as guards ought to be final to ensure that all threads are\n      guaranteed to use the same objects for synchronization.<\/p>"}
,"CCE_RA_INVALID_GUARD":{"name":"Guard expression is not valid","category":"Locking","description":"<p>The guard specified by the @GuardedBy annotation is not\n    valid.<\/p>\n\n    <h2>Details<\/h2>\n\n    <p>The following reasons can be reported by ThreadSafe when it\n    encounters an invalid <code>@GuardedBy<\/code> annotation:<\/p>\n\n    <ul>\n\n      <li><strong>Field not found.<\/strong> The field referenced by\n      the <code>@GuardedBy<\/code> annotation does not exist.<\/li>\n\n      <li><strong>Field is not a valid guard because its type is\n      primitive.<\/strong>\n      The field referenced by the <code>@GuardedBy<\/code> annotation\n      is not of reference type. Only fields of reference type (i.e.,\n      non primitive type) are suitable for use as guards.<\/li>\n\n      <li><strong>Field is static and must not be qualified with\n      'this'.<\/strong>\n      The <code>@GuardedBy<\/code> annotation appears to be referencing\n      an instance field because the field name is qualified with\n      'this', but the actual field is a static field.\n      To correct the problem, the 'this' qualifier should be removed\n      or replaced with the class name.<\/li>\n\n      <li><strong>Field is not static and must not be qualified with\n      a class name.<\/strong>\n      The <code>@GuardedBy<\/code> annotation appears to be referencing\n      a static field, because the field name is qualified with a class\n      name, but the referenced field is an instance field.\n      To correct the problem, the qualifier should be removed, or\n      replaced with 'this'.<\/li>\n\n      <li><strong>Class not found in this package.<\/strong>\n      The class referenced by the <code>@GuardedBy<\/code> annotation\n      could not be found.\n      Note that ThreadSafe will only look for the class in the\n      package where the <code>@GuardedBy<\/code> annotation is used.<\/li>\n\n      <li><strong>Instance field used to guard static field.<\/strong>\n      The <code>@GuardedBy<\/code> annotation refers to a static field,\n      but the annotation is used on an instance (that is, non-static)\n      field. Typically, instance fields should be guarded by 'this' or\n      another instance field.<\/li>\n\n      <li><strong>Could not parse @GuardedBy annotation value.<\/strong>\n      ThreadSafe has been unable to understand the guard specifier in this\n      annotation.<\/li>\n\n      <li><strong>The @GuardedBy annotation does not have the expected\n      type.<\/strong>\n      The <code>@GuardedBy<\/code> annotation that was on the classpath\n      when this class was compiled did not have the expected type.\n      The @GuardedBy annotation should have a single element 'value'\n      of type String.\n      ThreadSafe understands both the\n      <code>net.jcip.annotations.GuardedBy<\/code> and\n      <code>javax.annotation.concurrent.GuardedBy<\/code>\n      annotations.<\/li>\n\n    <\/ul>\n\n    <p>The list below shows the valid forms for the <code>@GuardedBy<\/code>\n    parameter:<\/p>\n\n    <ul>\n\n      <li><code>\"this\"<\/code>: the annotated field is guarded by a\n      lock held on the enclosing instance.<\/li>\n\n      <li><code>\"fieldName\"<\/code> and <code>\"this.fieldName\"<\/code>:\n      the annotated field is guarded by a lock held on the object\n      referenced by the field <code>fieldName<\/code> in the same\n      instance. If <code>fieldName<\/code> is not a field of reference\n      type (i.e., it is of primitive type: <code>int<\/code>,\n      <code>long<\/code>, <code>float<\/code>, or <code>double<\/code>),\n      then the annotation is invalid. If <code>fieldName<\/code> is of\n      a type that is an implementation of the\n      <code>java.util.concurrent.locks.Lock<\/code> interface, then it\n      is expected that the annotated field is guarded by the use of\n      <code>fieldName.lock()<\/code> instead of\n      <code>synchronized<\/code> blocks.<\/li>\n\n      <li><code>\"C.class\"<\/code>: the annotated field is guarded by a\n      lock held on the class <code>C<\/code>.<\/li>\n\n      <li><code>\"C.fieldName\"<\/code>: the annotated field is guarded\n      by a lock held on the object referenced by the <em>static<\/em>\n      field <code>fieldName<\/code>. If <code>fieldName<\/code> is not a\n      field of reference type (i.e., it is of primitive type:\n      <code>int<\/code>, <code>long<\/code>, <code>float<\/code>, or\n      <code>double<\/code>), then the annotation is invalid. If\n      <code>fieldName<\/code> is of a type that is an implementation of\n      the <code>java.util.concurrent.locks.Lock<\/code> interface, then\n      it is expected that the annotated field is guarded by the use of\n      <code>fieldName.lock()<\/code> instead of\n      <code>synchronized<\/code> blocks.<\/li>\n\n    <\/ul>"}
};