12.1
3) Inject some faults in the MSQueue implementation and see whether the test
detects them. Describe the faults and whether the test detects them, and if it
does detect them, how it fails.

ENQUEUE ERRORS INJECTED:
We removed the check in enque (E9) whether a new tail has been added while trying to set
last.next. This might give an error, that is hard to produce.

Node<T> last = tail.get(), next = last.next;
if (true /*last == tail.get()*/) {}

Result: Our test does not capture/reproduce an error.

We injected an error bypassing the check for the next value being null.
This error looks like it could possibly overwrite a value at the tail
if the tail has been updated bu another interleaving thread.
Again this might require a certain kind of interleaving operations to occur.

Node<T> last = tail.get(), next = last.next;
if (last == tail.get()) {
  if (true /*next == null*/)  { <-------- ERROR HERE
    // In quiescent state, try inserting new node
    if (nextUpdater.compareAndSet(last, next, node)) {

Result: Our tests did not capture/reproduce an error.

DEQUEUE ERRORS INJECTED:

Basically we injected the same two errors in the dequeue method. (Not simultaniesly).
As for the enqueue methods this might require certain interleavings to produce errors.

Node<T> first = head.get(), last = tail.get(), next = first.next;
if (true /*first == head.get()*/) {  <------- ERROR HERE
  if (true /*first == last*/) { <--------- AND HERE
    if (next == null)
      return null;
Result: Our tests did not capture/reproduce the error.

12.2
1) The checks performed at source lines E7 and D5 look reasonable enough, but are
they really useful? For instance, it seems that right after (last == tail.get())
was successfully evaluated to true at E7, another thread could modify tail.
Hence it seems that the check does not substantially contribute to the
correctness of the data structure.

These checks (who removed did not alter any test results) from a thread safety
perspective are not reasonable.
They look as if they're ment to prevent situations where the head and tail
are overwritten by other threads. But these checks dont protect the class, as
the atomicity lies in the CompareAndSet method which ensures the safety.
Without the atomicity of CompareAndSet, theres plenty of room for
interleaving operations making a mess of the queue.
See figure1.jpg for an intermistic drawing
of a situation where this might
occur.

2) Run the sequential and concurrent tests from Exercise12.1 on a version of the
MSQueueclass in which you have deleted the check at line E7 in the source code.
Does it pass the test?

Way ahead of you.. See question 12.1 3).

3) Run the sequential and concurrent tests from Exercise12.1 on a version of the
MSQueueclass in which you have deleted the check at line D7 in the source code.
Does it pass the test?

Way ahead of you.. See question 12.1 3) part two.

4) If the checks at lines E7 and D5 are indeed unnecessary for correctness,
what other reasons could there be to include them in the code?
How would you test your hypotheses about such reasons?

There's some overhead in proceeding past E7 and D5 if the last element
has been changed. So to up the performance these checks are introduced.
This can be tested with performance measurements (like your timing framework).

5) Describe and conduct an experiment to cast some light on the role of one
of E7 and D5.

See answer to 12.3 4) for test and results.
